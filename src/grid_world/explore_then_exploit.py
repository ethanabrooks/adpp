import grid_world.ad
from data import Step
from grid_world.value_iteration import ValueIteration
from pretty import console


class Data(grid_world.ad.Data):
    def __init__(self, *args, **kwargs):
        self._episodes_per_rollout = 0
        super().__init__(*args, **kwargs)

    def collect_data(self, grid_world: ValueIteration, **kwargs):
        def get_trajectory(Pi, t):
            g, s, a, r, d = grid_world.get_trajectories(
                Pi=Pi, n_episodes=self.n_episodes
            )
            console.log(f"Round: {t}. Reward: {r.sum(-1).mean().item():.2f}.")
            self._episodes_per_rollout += self.n_episodes
            return Step(tasks=g, observations=s, actions=a, rewards=r), d

        console.log("Value iteration...")
        Pi = grid_world.create_exploration_policy()
        Pi = Pi[None].tile(self.n_data, 1, 1)

        yield get_trajectory(Pi, t=0)
        for t, (V, Pi) in enumerate(
            (grid_world.value_iteration(**kwargs, n_rounds=self.n_rounds)), start=1
        ):
            console.log(f"Round: {t}.  Value: {V.mean().item():.2f}.")
            if self.yield_every is not None and t % self.yield_every == 0:
                yield get_trajectory(Pi, t=t)

        yield get_trajectory(Pi, t=t)

    @property
    def episodes_per_rollout(self):
        return self._episodes_per_rollout
